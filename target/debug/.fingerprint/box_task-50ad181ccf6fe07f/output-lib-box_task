{"message":"recursive type `List` has infinite size","code":{"code":"E0072","explanation":"A recursive type has infinite size because it doesn't have an indirection.\n\nErroneous code example:\n\n```compile_fail,E0072\nstruct ListNode {\n    head: u8,\n    tail: Option<ListNode>, // error: no indirection here so impossible to\n                            //        compute the type's size\n}\n```\n\nWhen defining a recursive struct or enum, any use of the type being defined\nfrom inside the definition must occur behind a pointer (like `Box`, `&` or\n`Rc`). This is because structs and enums must have a well-defined size, and\nwithout the pointer, the size of the type would need to be unbounded.\n\nIn the example, the type cannot have a well-defined size, because it needs to be\narbitrarily large (since we would be able to nest `ListNode`s to any depth).\nSpecifically,\n\n```plain\nsize of `ListNode` = 1 byte for `head`\n                   + 1 byte for the discriminant of the `Option`\n                   + size of `ListNode`\n```\n\nOne way to fix this is by wrapping `ListNode` in a `Box`, like so:\n\n```\nstruct ListNode {\n    head: u8,\n    tail: Option<Box<ListNode>>,\n}\n```\n\nThis works because `Box` is a pointer, so its size is well-known.\n"},"level":"error","spans":[{"file_name":"Standard Library Types\\Smart Pointers\\Box Task\\src\\lib.rs","byte_start":58,"byte_end":62,"line_start":3,"line_end":3,"column_start":15,"column_end":19,"is_primary":false,"text":[{"text":"    Cons(i32, List),","highlight_start":15,"highlight_end":19}],"label":"recursive without indirection","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"Standard Library Types\\Smart Pointers\\Box Task\\src\\lib.rs","byte_start":28,"byte_end":41,"line_start":2,"line_end":2,"column_start":1,"column_end":14,"is_primary":true,"text":[{"text":"pub enum List {","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle","code":null,"level":"help","spans":[{"file_name":"Standard Library Types\\Smart Pointers\\Box Task\\src\\lib.rs","byte_start":58,"byte_end":58,"line_start":3,"line_end":3,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"    Cons(i32, List),","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"Standard Library Types\\Smart Pointers\\Box Task\\src\\lib.rs","byte_start":62,"byte_end":62,"line_start":3,"line_end":3,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    Cons(i32, List),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":">","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0072]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: recursive type `List` has infinite size\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mStandard Library Types\\Smart Pointers\\Box Task\\src\\lib.rs:2:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum List {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Cons(i32, List),\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrecursive without indirection\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    Cons(i32, \u001b[0m\u001b[0m\u001b[38;5;10mBox<\u001b[0m\u001b[0mList\u001b[0m\u001b[0m\u001b[38;5;10m>\u001b[0m\u001b[0m),\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0072`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about this error, try `rustc --explain E0072`.\u001b[0m\n"}
